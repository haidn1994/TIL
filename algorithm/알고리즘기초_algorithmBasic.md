## 알고리즘 이란?

알고리즘이란 어떤 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어내는 과정을 기술한 것이다.  
그리고 그런 과정은 여러 명령어들의 유한집합(finite set)으로 표현된다.  


알고리즘은 이런 정의 외에도 여러가지 특징을 지니는데, 하나씩 살펴보자.  

### 알고리즘이 무엇을 하는지 입력과 출력으로 명시할 수 있다.

알고리즘을 만들 때는 하고자 하는 작업을 명확하게 명시해야 한다.  
설계하려는 알고리즘이 "무엇을(what)" 하는지는 입력(input)과 출력(output)에 의해 명시할 수 있다.  


예를 들어서 학생 100명의 수학시험 점수를 입력으로 받아, 오름차순으로 정렬한 리스트를 출력하는 알고리즘을 표현해 보자.

* 입력 : 100개의 정수
* 출력 : 입력된 100개의 정수를 오름차순으로 정렬한 리스트

### 명확성

알고리즘의 각 단계는 명확해야 한다.  
알고리즘이 명확하다는 것은 모호하지 않고 이해하기 쉽다는 것을 말한다.  


하지만 명확하다는 것을 자세한것과 혼동하면 안된다.  
명확하게 표현한다고 지나친 세부 사항을 구구절절히 기호적으로 기술하는 것은 오히려 알고리즘의 명확성을 떨어뜨린다.  

### 유한성

알고리즘은 단계들을 유한한 횟수로 거친 후 문제를 해결하고 종료해야 한다.  

### 효율성

**효율성**은 모든 알고리즘이 반드시 가져야 할 특징은 아니지만 어떤 알고리즘이 효율적이지 못하다면 실질적으로 어떤 문제를 풀 수 있다고 하기 어렵다.  
따라서 이 알고리즘이 좋은 알고리즘인지, 나쁜 알고리즘인지 평가할 때 효율성을 가지고 판단한다. 


그리고 컴퓨터에서는 CPU 자원(시간)과 메모리 자원(공간)라는 두 자원을 얼마나 소모하는지가 효율성의 중점이 된다.  

* 시간 복잡도 : 컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관계를 나타내는 척도다. 일반적으로 시간 복잡도는 점근 표기법을 사용하여 표현한다.
* 공간 복잡도 : 컴퓨터 프로그램의 입력값과 필요한 메모리 공간의 상관관계를 나타내는 척도다. 보통 연산에 걸리는 시간에 비해 메모리가 싸기 때문에 공간 복잡도까지 따지는 경우는 적지만, 어려운 동적 프로그래밍 문제나 굉장히 어려운 문제의 경우에는 공간 복잡도도 중요하게 다뤄진다.  
## 재귀(recursion)

하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 방식으로 주어진 문제를 푸는 방법이다.  
물론 입력값의 변화 없이 자신을 다시 호출하면 무한히 반복하다가 멈춰버린다. 따라서 실제 재귀함수를 어떤 문제를 풀 목적으로 사용한다면 다음 조건을 만족해야 한다.

* 입력값이 기저 사례로 수렴해야 한다.
* 기저 사례/종료 조건(base case)가 있어야 한다.
* 맨 아래가 아닌 수에서 어떻게 예전 값과 같이 계산하는지를 표현하는 요소인 반복 조건이 있다.  
	* 반복조건 내에서 실행되는 함수의 시간 복잡도가 재귀함수 성능에 가장 큰 영향을 미친다.  

### 재귀를 배우는 것이 왜 중요할까?

컴퓨터과학을 배우면서 재귀에 대해서 공부하는 것은 참으로 중요하다.  
재귀는 어떤 문제를 해결하는 과정에서 자신과 똑같지만 크기(입력값으로 표현할 수 있음)가 다른 문제를 발견하고 이들의 관계를 파악함으로써 문제 해결에 간명하게 접근하는 방식이다. 


사실 여러분은 고등학교 때 부터 이런 사고방식을 훈련하는 과정을 밟았다.  
고등학교 수학에서 배우는 수학적 귀납법이 이와 관련이 깊다. 수열의 점화식도 이의 기초적인 형태다.  
귀납적 사고라는 것은 성격(같은 알고리즘)이 같지만 크기가 다른(입력값이 다른) 문제 간의 관계를 파악하는 것이다.  


자기호출을 이용하는 알고리즘의 정당성은 수학적 귀납법과 관련이 깊다.  
수학적 귀납법이란 자신보다 작은 문제에 대해 결론이 옳음을 가정하고 자신과 이 작은 문제와의 관계를 통해서 자신에 대해서도 결론이 옳음을 보이는 것이다.재귀 알고리즘이 자신보다 작은 문제를 자기호출하는 것은 수학적 귀납법에서 자신보다 작은 문제에 대해 결론이 옳음을 가정하는 것과 일치한다. 즉, 자신보다 작은 문제에 대해서는 이 알고리즘이 제대로 동작한다고 가정하는 것이다. 자기호출을 이용하는 알고리즘에서 자기호출을 제외한 나머지 부분은 대부분 크기가 다른 문제간의 관계를 반영하기 위한 것이다.  

## 참고문헌

* 쉽게 배우는 알고리즘 - 문병로 - 한빛 아카데미
* [나무위키 - 알고리즘](https://namu.wiki/w/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
* [나무위키 - 재귀함수](https://namu.wiki/w/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98)
* [나무위키 - 시간 복잡도](https://namu.wiki/w/%EC%8B%9C%EA%B0%84%20%EB%B3%B5%EC%9E%A1%EB%8F%84)
